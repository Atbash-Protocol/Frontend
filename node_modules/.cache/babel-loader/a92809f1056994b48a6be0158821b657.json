{"ast":null,"code":"import { ethers } from \"ethers\";\nimport { getAddresses } from \"../../constants\";\nimport { TimeTokenContract, MemoTokenContract, MimTokenContract } from \"../../abi\";\nimport { setAll } from \"../../helpers\";\nimport { createSlice, createSelector, createAsyncThunk } from \"@reduxjs/toolkit\";\nexport const getBalances = createAsyncThunk(\"account/getBalances\", async _ref => {\n  let {\n    address,\n    networkID,\n    provider\n  } = _ref;\n  const addresses = getAddresses(networkID);\n  const sBASHContract = new ethers.Contract(addresses.SBASH_ADDRESS, MemoTokenContract, provider);\n  const wsBASHContract = new ethers.Contract(addresses.WSBASH_ADDRESS, MemoTokenContract, provider);\n  const sBASHBalance = await sBASHContract.balanceOf(address);\n  const wsBASHBalance = await wsBASHContract.balanceOf(address);\n  const sbContract = new ethers.Contract(addresses.BASH_ADDRESS, TimeTokenContract, provider);\n  const BASHbalance = await sbContract.balanceOf(address);\n  return {\n    balances: {\n      wsBASH: ethers.utils.formatEther(wsBASHBalance),\n      sBASH: ethers.utils.formatUnits(sBASHBalance, \"gwei\"),\n      BASH: ethers.utils.formatUnits(BASHbalance, \"gwei\")\n    }\n  };\n});\nexport const loadAccountDetails = createAsyncThunk(\"account/loadAccountDetails\", async _ref2 => {\n  let {\n    networkID,\n    provider,\n    address\n  } = _ref2;\n  let BASHbalance = 0;\n  let sBASHBalance = 0;\n  let wsBASHBalance = 0;\n  let stakeAllowance = 0;\n  let unstakeAllowance = 0;\n  let wrapAllowance = 0;\n  let redeemAllowance = 0;\n  const addresses = getAddresses(networkID);\n\n  if (addresses.BASH_ADDRESS) {\n    const sbContract = new ethers.Contract(addresses.BASH_ADDRESS, TimeTokenContract, provider);\n    BASHbalance = await sbContract.balanceOf(address);\n    stakeAllowance = await sbContract.allowance(address, addresses.STAKING_HELPER_ADDRESS);\n    redeemAllowance = await sbContract.allowance(address, addresses.REDEEM_ADDRESS);\n  }\n\n  if (addresses.SBASH_ADDRESS) {\n    const sBASHContract = new ethers.Contract(addresses.SBASH_ADDRESS, MemoTokenContract, provider);\n    sBASHBalance = await sBASHContract.balanceOf(address);\n    wrapAllowance = await sBASHContract.allowance(address, addresses.WSBASH_ADDRESS);\n    unstakeAllowance = await sBASHContract.allowance(address, addresses.STAKING_ADDRESS);\n  }\n\n  if (addresses.WSBASH_ADDRESS) {\n    const wsBASHContract = new ethers.Contract(addresses.WSBASH_ADDRESS, MemoTokenContract, provider);\n    wsBASHBalance = await wsBASHContract.balanceOf(address);\n  }\n\n  return {\n    balances: {\n      wsBASH: ethers.utils.formatEther(wsBASHBalance),\n      sBASH: ethers.utils.formatUnits(sBASHBalance, \"gwei\"),\n      BASH: ethers.utils.formatUnits(BASHbalance, \"gwei\")\n    },\n    redeeming: {\n      BASH: Number(redeemAllowance)\n    },\n    staking: {\n      BASH: Number(stakeAllowance),\n      sBASH: Number(unstakeAllowance)\n    },\n    wrapping: {\n      sBASHAllowance: Number(wrapAllowance)\n    }\n  };\n});\nexport const calculateUserBondDetails = createAsyncThunk(\"account/calculateUserBondDetails\", async _ref3 => {\n  let {\n    address,\n    bond,\n    networkID,\n    provider\n  } = _ref3;\n\n  if (!address) {\n    return new Promise(resevle => {\n      resevle({\n        bond: \"\",\n        displayName: \"\",\n        bondIconSvg: \"\",\n        isLP: false,\n        allowance: 0,\n        balance: 0,\n        interestDue: 0,\n        bondMaturationBlock: 0,\n        pendingPayout: \"\",\n        avaxBalance: 0\n      });\n    });\n  }\n\n  const bondContract = bond.getContractForBond(networkID, provider);\n  const reserveContract = bond.getContractForReserve(networkID, provider);\n  let interestDue, pendingPayout, bondMaturationBlock;\n  const bondDetails = await bondContract.bondInfo(address);\n  interestDue = bondDetails.payout / Math.pow(10, 9);\n  bondMaturationBlock = Number(bondDetails.vesting) + Number(bondDetails.lastTime);\n  pendingPayout = await bondContract.pendingPayoutFor(address);\n  let allowance,\n      balance = \"0\";\n  allowance = await reserveContract.allowance(address, bond.getAddressForBond(networkID));\n  balance = await reserveContract.balanceOf(address);\n  const balanceVal = ethers.utils.formatEther(balance);\n  const avaxBalance = await provider.getSigner().getBalance();\n  const avaxVal = ethers.utils.formatEther(avaxBalance);\n  const pendingPayoutVal = ethers.utils.formatUnits(pendingPayout, \"gwei\");\n  return {\n    bond: bond.name,\n    displayName: bond.displayName,\n    bondIconSvg: bond.bondIconSvg,\n    isLP: bond.isLP,\n    allowance: Number(allowance),\n    balance: Number(balanceVal),\n    avaxBalance: Number(avaxVal),\n    interestDue,\n    bondMaturationBlock,\n    pendingPayout: Number(pendingPayoutVal)\n  };\n});\nexport const calculateUserTokenDetails = createAsyncThunk(\"account/calculateUserTokenDetails\", async _ref4 => {\n  let {\n    address,\n    token,\n    networkID,\n    provider\n  } = _ref4;\n\n  if (!address) {\n    return new Promise(resevle => {\n      resevle({\n        token: \"\",\n        address: \"\",\n        img: \"\",\n        allowance: 0,\n        balance: 0\n      });\n    });\n  }\n\n  if (token.isAvax) {\n    const avaxBalance = await provider.getSigner().getBalance();\n    const avaxVal = ethers.utils.formatEther(avaxBalance);\n    return {\n      token: token.name,\n      tokenIcon: token.img,\n      balance: Number(avaxVal),\n      isAvax: true\n    };\n  }\n\n  const addresses = getAddresses(networkID);\n  const tokenContract = new ethers.Contract(token.address, MimTokenContract, provider);\n  let allowance,\n      balance = \"0\";\n  allowance = await tokenContract.allowance(address, addresses.ZAPIN_ADDRESS);\n  balance = await tokenContract.balanceOf(address);\n  const balanceVal = Number(balance) / Math.pow(10, token.decimals);\n  return {\n    token: token.name,\n    address: token.address,\n    img: token.img,\n    allowance: Number(allowance),\n    balance: Number(balanceVal)\n  };\n});\nconst initialState = {\n  loading: true,\n  bonds: {},\n  balances: {\n    wsBASH: \"\",\n    sBASH: \"\",\n    BASH: \"\"\n  },\n  staking: {\n    BASH: 0,\n    sBASH: 0\n  },\n  wrapping: {\n    sBASHAllowance: 0\n  },\n  redeeming: {\n    BASH: 0\n  },\n  tokens: {}\n};\nconst accountSlice = createSlice({\n  name: \"account\",\n  initialState,\n  reducers: {\n    fetchAccountSuccess(state, action) {\n      setAll(state, action.payload);\n    }\n\n  },\n  extraReducers: builder => {\n    builder.addCase(loadAccountDetails.pending, state => {\n      state.loading = true;\n    }).addCase(loadAccountDetails.fulfilled, (state, action) => {\n      setAll(state, action.payload);\n      state.loading = false;\n    }).addCase(loadAccountDetails.rejected, (state, _ref5) => {\n      let {\n        error\n      } = _ref5;\n      state.loading = false;\n      console.log(error);\n    }).addCase(getBalances.pending, state => {\n      state.loading = true;\n    }).addCase(getBalances.fulfilled, (state, action) => {\n      setAll(state, action.payload);\n      state.loading = false;\n    }).addCase(getBalances.rejected, (state, _ref6) => {\n      let {\n        error\n      } = _ref6;\n      state.loading = false;\n      console.log(error);\n    }).addCase(calculateUserBondDetails.pending, (state, action) => {\n      state.loading = true;\n    }).addCase(calculateUserBondDetails.fulfilled, (state, action) => {\n      if (!action.payload) return;\n      const bond = action.payload.bond;\n      state.bonds[bond] = action.payload;\n      state.loading = false;\n    }).addCase(calculateUserBondDetails.rejected, (state, _ref7) => {\n      let {\n        error\n      } = _ref7;\n      state.loading = false;\n      console.log(error);\n    }).addCase(calculateUserTokenDetails.pending, (state, action) => {\n      state.loading = true;\n    }).addCase(calculateUserTokenDetails.fulfilled, (state, action) => {\n      if (!action.payload) return;\n      const token = action.payload.token;\n      state.tokens[token] = action.payload;\n      state.loading = false;\n    }).addCase(calculateUserTokenDetails.rejected, (state, _ref8) => {\n      let {\n        error\n      } = _ref8;\n      state.loading = false;\n      console.log(error);\n    });\n  }\n});\nexport default accountSlice.reducer;\nexport const {\n  fetchAccountSuccess\n} = accountSlice.actions;\n\nconst baseInfo = state => state.account;\n\nexport const getAccountState = createSelector(baseInfo, account => account);","map":{"version":3,"sources":["/home/beard/Documents/V1Frontend/v1-frontend/src/store/slices/account-slice.ts"],"names":["ethers","getAddresses","TimeTokenContract","MemoTokenContract","MimTokenContract","setAll","createSlice","createSelector","createAsyncThunk","getBalances","address","networkID","provider","addresses","sBASHContract","Contract","SBASH_ADDRESS","wsBASHContract","WSBASH_ADDRESS","sBASHBalance","balanceOf","wsBASHBalance","sbContract","BASH_ADDRESS","BASHbalance","balances","wsBASH","utils","formatEther","sBASH","formatUnits","BASH","loadAccountDetails","stakeAllowance","unstakeAllowance","wrapAllowance","redeemAllowance","allowance","STAKING_HELPER_ADDRESS","REDEEM_ADDRESS","STAKING_ADDRESS","redeeming","Number","staking","wrapping","sBASHAllowance","calculateUserBondDetails","bond","Promise","resevle","displayName","bondIconSvg","isLP","balance","interestDue","bondMaturationBlock","pendingPayout","avaxBalance","bondContract","getContractForBond","reserveContract","getContractForReserve","bondDetails","bondInfo","payout","Math","pow","vesting","lastTime","pendingPayoutFor","getAddressForBond","balanceVal","getSigner","getBalance","avaxVal","pendingPayoutVal","name","calculateUserTokenDetails","token","img","isAvax","tokenIcon","tokenContract","ZAPIN_ADDRESS","decimals","initialState","loading","bonds","tokens","accountSlice","reducers","fetchAccountSuccess","state","action","payload","extraReducers","builder","addCase","pending","fulfilled","rejected","error","console","log","reducer","actions","baseInfo","account","getAccountState"],"mappings":"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","sourcesContent":["import { ethers } from \"ethers\";\nimport { getAddresses } from \"../../constants\";\nimport { TimeTokenContract, MemoTokenContract, MimTokenContract } from \"../../abi\";\nimport { setAll } from \"../../helpers\";\n\nimport { createSlice, createSelector, createAsyncThunk } from \"@reduxjs/toolkit\";\nimport { JsonRpcProvider, StaticJsonRpcProvider } from \"@ethersproject/providers\";\nimport { Bond } from \"../../helpers/bond/bond\";\nimport { Networks } from \"../../constants/blockchain\";\nimport React from \"react\";\nimport { RootState } from \"../store\";\nimport { IToken } from \"../../helpers/tokens\";\n\ninterface IGetBalances {\n    address: string;\n    networkID: Networks;\n    provider: StaticJsonRpcProvider | JsonRpcProvider;\n}\n\ninterface IAccountBalances {\n    balances: {\n        wsBASH: string;\n        sBASH: string;\n        BASH: string;\n    };\n}\n\nexport const getBalances = createAsyncThunk(\"account/getBalances\", async ({ address, networkID, provider }: IGetBalances): Promise<IAccountBalances> => {\n    const addresses = getAddresses(networkID);\n\n    const sBASHContract = new ethers.Contract(addresses.SBASH_ADDRESS, MemoTokenContract, provider);\n    const wsBASHContract = new ethers.Contract(addresses.WSBASH_ADDRESS, MemoTokenContract, provider);\n    const sBASHBalance = await sBASHContract.balanceOf(address);\n    const wsBASHBalance = await wsBASHContract.balanceOf(address);\n    const sbContract = new ethers.Contract(addresses.BASH_ADDRESS, TimeTokenContract, provider);\n    const BASHbalance = await sbContract.balanceOf(address);\n\n    return {\n        balances: {\n            wsBASH: ethers.utils.formatEther(wsBASHBalance),\n            sBASH: ethers.utils.formatUnits(sBASHBalance, \"gwei\"),\n            BASH: ethers.utils.formatUnits(BASHbalance, \"gwei\"),\n        },\n    };\n});\n\ninterface ILoadAccountDetails {\n    address: string;\n    networkID: Networks;\n    provider: StaticJsonRpcProvider | JsonRpcProvider;\n}\n\ninterface IUserAccountDetails {\n    balances: {\n        BASH: string;\n        sBASH: string;\n        wsBASH: string;\n    };\n    redeeming: {\n        BASH: number;\n    };\n    staking: {\n        BASH: number;\n        sBASH: number;\n    };\n    wrapping: {\n        sBASHAllowance: number;\n    };\n}\n\nexport const loadAccountDetails = createAsyncThunk(\"account/loadAccountDetails\", async ({ networkID, provider, address }: ILoadAccountDetails): Promise<IUserAccountDetails> => {\n    let BASHbalance = 0;\n    let sBASHBalance = 0;\n    let wsBASHBalance = 0;\n    let stakeAllowance = 0;\n    let unstakeAllowance = 0;\n    let wrapAllowance = 0;\n    let redeemAllowance = 0;\n\n    const addresses = getAddresses(networkID);\n\n    if (addresses.BASH_ADDRESS) {\n        const sbContract = new ethers.Contract(addresses.BASH_ADDRESS, TimeTokenContract, provider);\n        BASHbalance = await sbContract.balanceOf(address);\n        stakeAllowance = await sbContract.allowance(address, addresses.STAKING_HELPER_ADDRESS);\n        redeemAllowance = await sbContract.allowance(address, addresses.REDEEM_ADDRESS);\n    }\n\n    if (addresses.SBASH_ADDRESS) {\n        const sBASHContract = new ethers.Contract(addresses.SBASH_ADDRESS, MemoTokenContract, provider);\n        sBASHBalance = await sBASHContract.balanceOf(address);\n        wrapAllowance = await sBASHContract.allowance(address, addresses.WSBASH_ADDRESS);\n        unstakeAllowance = await sBASHContract.allowance(address, addresses.STAKING_ADDRESS);\n    }\n\n    if (addresses.WSBASH_ADDRESS) {\n        const wsBASHContract = new ethers.Contract(addresses.WSBASH_ADDRESS, MemoTokenContract, provider);\n        wsBASHBalance = await wsBASHContract.balanceOf(address);\n    }\n\n    return {\n        balances: {\n            wsBASH: ethers.utils.formatEther(wsBASHBalance),\n            sBASH: ethers.utils.formatUnits(sBASHBalance, \"gwei\"),\n            BASH: ethers.utils.formatUnits(BASHbalance, \"gwei\"),\n        },\n        redeeming: {\n            BASH: Number(redeemAllowance),\n        },\n        staking: {\n            BASH: Number(stakeAllowance),\n            sBASH: Number(unstakeAllowance),\n        },\n        wrapping: {\n            sBASHAllowance: Number(wrapAllowance),\n        },\n    };\n});\n\ninterface ICalcUserBondDetails {\n    address: string;\n    bond: Bond;\n    provider: StaticJsonRpcProvider | JsonRpcProvider;\n    networkID: Networks;\n}\n\nexport interface IUserBondDetails {\n    allowance: number;\n    balance: number;\n    avaxBalance: number;\n    interestDue: number;\n    bondMaturationBlock: number;\n    pendingPayout: number; //Payout formatted in gwei.\n}\n\nexport const calculateUserBondDetails = createAsyncThunk(\"account/calculateUserBondDetails\", async ({ address, bond, networkID, provider }: ICalcUserBondDetails) => {\n    if (!address) {\n        return new Promise<any>(resevle => {\n            resevle({\n                bond: \"\",\n                displayName: \"\",\n                bondIconSvg: \"\",\n                isLP: false,\n                allowance: 0,\n                balance: 0,\n                interestDue: 0,\n                bondMaturationBlock: 0,\n                pendingPayout: \"\",\n                avaxBalance: 0,\n            });\n        });\n    }\n\n    const bondContract = bond.getContractForBond(networkID, provider);\n    const reserveContract = bond.getContractForReserve(networkID, provider);\n\n    let interestDue, pendingPayout, bondMaturationBlock;\n\n    const bondDetails = await bondContract.bondInfo(address);\n    interestDue = bondDetails.payout / Math.pow(10, 9);\n    bondMaturationBlock = Number(bondDetails.vesting) + Number(bondDetails.lastTime);\n    pendingPayout = await bondContract.pendingPayoutFor(address);\n\n    let allowance,\n        balance = \"0\";\n\n    allowance = await reserveContract.allowance(address, bond.getAddressForBond(networkID));\n    balance = await reserveContract.balanceOf(address);\n    const balanceVal = ethers.utils.formatEther(balance);\n\n    const avaxBalance = await provider.getSigner().getBalance();\n    const avaxVal = ethers.utils.formatEther(avaxBalance);\n\n    const pendingPayoutVal = ethers.utils.formatUnits(pendingPayout, \"gwei\");\n\n    return {\n        bond: bond.name,\n        displayName: bond.displayName,\n        bondIconSvg: bond.bondIconSvg,\n        isLP: bond.isLP,\n        allowance: Number(allowance),\n        balance: Number(balanceVal),\n        avaxBalance: Number(avaxVal),\n        interestDue,\n        bondMaturationBlock,\n        pendingPayout: Number(pendingPayoutVal),\n    };\n});\n\ninterface ICalcUserTokenDetails {\n    address: string;\n    token: IToken;\n    provider: StaticJsonRpcProvider | JsonRpcProvider;\n    networkID: Networks;\n}\n\nexport interface IUserTokenDetails {\n    allowance: number;\n    balance: number;\n    isAvax?: boolean;\n}\n\nexport const calculateUserTokenDetails = createAsyncThunk(\"account/calculateUserTokenDetails\", async ({ address, token, networkID, provider }: ICalcUserTokenDetails) => {\n    if (!address) {\n        return new Promise<any>(resevle => {\n            resevle({\n                token: \"\",\n                address: \"\",\n                img: \"\",\n                allowance: 0,\n                balance: 0,\n            });\n        });\n    }\n\n    if (token.isAvax) {\n        const avaxBalance = await provider.getSigner().getBalance();\n        const avaxVal = ethers.utils.formatEther(avaxBalance);\n\n        return {\n            token: token.name,\n            tokenIcon: token.img,\n            balance: Number(avaxVal),\n            isAvax: true,\n        };\n    }\n\n    const addresses = getAddresses(networkID);\n\n    const tokenContract = new ethers.Contract(token.address, MimTokenContract, provider);\n\n    let allowance,\n        balance = \"0\";\n\n    allowance = await tokenContract.allowance(address, addresses.ZAPIN_ADDRESS);\n    balance = await tokenContract.balanceOf(address);\n\n    const balanceVal = Number(balance) / Math.pow(10, token.decimals);\n\n    return {\n        token: token.name,\n        address: token.address,\n        img: token.img,\n        allowance: Number(allowance),\n        balance: Number(balanceVal),\n    };\n});\n\nexport interface IAccountSlice {\n    bonds: { [key: string]: IUserBondDetails };\n    balances: {\n        wsBASH: string;\n        sBASH: string;\n        BASH: string;\n    };\n    loading: boolean;\n    redeeming: {\n        BASH: number;\n    };\n    staking: {\n        BASH: number;\n        sBASH: number;\n    };\n    wrapping: {\n        sBASHAllowance: number;\n    };\n    tokens: { [key: string]: IUserTokenDetails };\n}\n\nconst initialState: IAccountSlice = {\n    loading: true,\n    bonds: {},\n    balances: { wsBASH: \"\", sBASH: \"\", BASH: \"\" },\n    staking: { BASH: 0, sBASH: 0 },\n    wrapping: { sBASHAllowance: 0 },\n    redeeming: { BASH: 0 },\n    tokens: {},\n};\n\nconst accountSlice = createSlice({\n    name: \"account\",\n    initialState,\n    reducers: {\n        fetchAccountSuccess(state, action) {\n            setAll(state, action.payload);\n        },\n    },\n    extraReducers: builder => {\n        builder\n            .addCase(loadAccountDetails.pending, state => {\n                state.loading = true;\n            })\n            .addCase(loadAccountDetails.fulfilled, (state, action) => {\n                setAll(state, action.payload);\n                state.loading = false;\n            })\n            .addCase(loadAccountDetails.rejected, (state, { error }) => {\n                state.loading = false;\n                console.log(error);\n            })\n            .addCase(getBalances.pending, state => {\n                state.loading = true;\n            })\n            .addCase(getBalances.fulfilled, (state, action) => {\n                setAll(state, action.payload);\n                state.loading = false;\n            })\n            .addCase(getBalances.rejected, (state, { error }) => {\n                state.loading = false;\n                console.log(error);\n            })\n            .addCase(calculateUserBondDetails.pending, (state, action) => {\n                state.loading = true;\n            })\n            .addCase(calculateUserBondDetails.fulfilled, (state, action) => {\n                if (!action.payload) return;\n                const bond = action.payload.bond;\n                state.bonds[bond] = action.payload;\n                state.loading = false;\n            })\n            .addCase(calculateUserBondDetails.rejected, (state, { error }) => {\n                state.loading = false;\n                console.log(error);\n            })\n            .addCase(calculateUserTokenDetails.pending, (state, action) => {\n                state.loading = true;\n            })\n            .addCase(calculateUserTokenDetails.fulfilled, (state, action) => {\n                if (!action.payload) return;\n                const token = action.payload.token;\n                state.tokens[token] = action.payload;\n                state.loading = false;\n            })\n            .addCase(calculateUserTokenDetails.rejected, (state, { error }) => {\n                state.loading = false;\n                console.log(error);\n            });\n    },\n});\n\nexport default accountSlice.reducer;\n\nexport const { fetchAccountSuccess } = accountSlice.actions;\n\nconst baseInfo = (state: RootState) => state.account;\n\nexport const getAccountState = createSelector(baseInfo, account => account);\n"]},"metadata":{},"sourceType":"module"}