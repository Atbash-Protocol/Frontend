{"ast":null,"code":"import { ethers } from \"ethers\";\nimport { getAddresses } from \"../../constants\";\nimport { WrappingContract, MemoTokenContract } from \"../../abi\";\nimport { clearPendingTxn, fetchPendingTxns, getStakingTypeText } from \"./pending-txns-slice\";\nimport { createAsyncThunk } from \"@reduxjs/toolkit\";\nimport { fetchAccountSuccess, getBalances } from \"./account-slice\";\nimport { warning, success, info } from \"./messages-slice\";\nimport { messages } from \"../../constants/messages\";\nimport { getGasPrice } from \"../../helpers/get-gas-price\";\nimport { metamaskErrorWrap } from \"../../helpers/metamask-error-wrap\";\nimport { sleep } from \"../../helpers\";\nimport i18n from \"../../i18n\";\nexport const changeApproval = createAsyncThunk(\"stake/changeApproval\", async (_ref, _ref2) => {\n  let {\n    token,\n    provider,\n    address,\n    networkID\n  } = _ref;\n  let {\n    dispatch\n  } = _ref2;\n\n  if (!provider) {\n    dispatch(warning({\n      text: messages.please_connect_wallet\n    }));\n    return;\n  }\n\n  const addresses = getAddresses(networkID);\n  const signer = provider.getSigner();\n  const sBASHContract = new ethers.Contract(addresses.SBASH_ADDRESS, MemoTokenContract, signer);\n  let approveTx;\n\n  try {\n    const gasPrice = await getGasPrice(provider);\n\n    if (token === \"sBASH\") {\n      approveTx = await sBASHContract.approve(addresses.WSBASH_ADDRESS, ethers.constants.MaxUint256, {\n        gasPrice\n      });\n    }\n\n    const text = token === \"sBASH\" ? i18n.t(\"wrap:ApproveWrapping\") : \"\";\n    const pendingTxnType = token === \"sBASH\" ? \"approve_wrapping\" : \"\";\n    dispatch(fetchPendingTxns({\n      txnHash: approveTx.hash,\n      text,\n      type: pendingTxnType\n    }));\n    await approveTx.wait();\n    dispatch(success({\n      text: messages.tx_successfully_send\n    }));\n  } catch (err) {\n    return metamaskErrorWrap(err, dispatch);\n  } finally {\n    if (approveTx) {\n      dispatch(clearPendingTxn(approveTx.hash));\n    }\n  }\n\n  await sleep(2);\n  const wrapAllowance = await sBASHContract.allowance(address, addresses.WSBASH_ADDRESS);\n  return dispatch(fetchAccountSuccess({\n    wrapping: {\n      sbWrap: Number(wrapAllowance)\n    }\n  }));\n});\nexport const changeWrap = createAsyncThunk(\"stake/changeWrap\", async (_ref3, _ref4) => {\n  let {\n    action,\n    value,\n    provider,\n    address,\n    networkID\n  } = _ref3;\n  let {\n    dispatch\n  } = _ref4;\n\n  if (!provider) {\n    dispatch(warning({\n      text: messages.please_connect_wallet\n    }));\n    return;\n  }\n\n  const addresses = getAddresses(networkID);\n  const signer = provider.getSigner();\n  const wsBASH = new ethers.Contract(addresses.WSBASH_ADDRESS, WrappingContract, signer);\n  let wrapTx;\n\n  try {\n    const gasPrice = await getGasPrice(provider);\n\n    if (action === \"wrap\") {\n      console.log(value);\n      console.log(ethers.utils.parseEther(value));\n      wrapTx = await wsBASH.wrap(ethers.utils.parseUnits(value, \"gwei\"), {\n        gasPrice\n      });\n    } else {\n      wrapTx = await wsBASH.unwrap(ethers.utils.parseEther(value), {\n        gasPrice\n      });\n    }\n\n    const pendingTxnType = action === \"wrap\" ? i18n.t(\"wrap:Wrapping\") : i18n.t(\"wrap:Unwrapping\");\n    dispatch(fetchPendingTxns({\n      txnHash: wrapTx.hash,\n      text: getStakingTypeText(action),\n      type: pendingTxnType\n    }));\n    await wrapTx.wait();\n    dispatch(success({\n      text: messages.tx_successfully_send\n    }));\n  } catch (err) {\n    return metamaskErrorWrap(err, dispatch);\n  } finally {\n    if (wrapTx) {\n      dispatch(clearPendingTxn(wrapTx.hash));\n    }\n  }\n\n  dispatch(info({\n    text: messages.your_balance_update_soon\n  }));\n  await sleep(10);\n  await dispatch(getBalances({\n    address,\n    networkID,\n    provider\n  }));\n  dispatch(info({\n    text: messages.your_balance_updated\n  }));\n  return;\n});","map":{"version":3,"sources":["/home/beard/Documents/V1Frontend/v1-frontend/src/store/slices/wrap-thunk.ts"],"names":["ethers","getAddresses","WrappingContract","MemoTokenContract","clearPendingTxn","fetchPendingTxns","getStakingTypeText","createAsyncThunk","fetchAccountSuccess","getBalances","warning","success","info","messages","getGasPrice","metamaskErrorWrap","sleep","i18n","changeApproval","token","provider","address","networkID","dispatch","text","please_connect_wallet","addresses","signer","getSigner","sBASHContract","Contract","SBASH_ADDRESS","approveTx","gasPrice","approve","WSBASH_ADDRESS","constants","MaxUint256","t","pendingTxnType","txnHash","hash","type","wait","tx_successfully_send","err","wrapAllowance","allowance","wrapping","sbWrap","Number","changeWrap","action","value","wsBASH","wrapTx","console","log","utils","parseEther","wrap","parseUnits","unwrap","your_balance_update_soon","your_balance_updated"],"mappings":"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","sourcesContent":["import { ethers } from \"ethers\";\nimport { getAddresses } from \"../../constants\";\nimport { WrappingContract, TimeTokenContract, MemoTokenContract } from \"../../abi\";\nimport { clearPendingTxn, fetchPendingTxns, getStakingTypeText } from \"./pending-txns-slice\";\nimport { createAsyncThunk } from \"@reduxjs/toolkit\";\nimport { fetchAccountSuccess, getBalances } from \"./account-slice\";\nimport { JsonRpcProvider, StaticJsonRpcProvider } from \"@ethersproject/providers\";\nimport { Networks } from \"../../constants/blockchain\";\nimport { warning, success, info, error } from \"./messages-slice\";\nimport { messages } from \"../../constants/messages\";\nimport { getGasPrice } from \"../../helpers/get-gas-price\";\nimport { metamaskErrorWrap } from \"../../helpers/metamask-error-wrap\";\nimport { sleep } from \"../../helpers\";\n\nimport i18n from \"../../i18n\";\n\ninterface IChangeApproval {\n    token: string;\n    provider: StaticJsonRpcProvider | JsonRpcProvider;\n    address: string;\n    networkID: Networks;\n}\n\nexport const changeApproval = createAsyncThunk(\"stake/changeApproval\", async ({ token, provider, address, networkID }: IChangeApproval, { dispatch }) => {\n    if (!provider) {\n        dispatch(warning({ text: messages.please_connect_wallet }));\n        return;\n    }\n    const addresses = getAddresses(networkID);\n\n    const signer = provider.getSigner();\n    const sBASHContract = new ethers.Contract(addresses.SBASH_ADDRESS, MemoTokenContract, signer);\n\n    let approveTx;\n    try {\n        const gasPrice = await getGasPrice(provider);\n\n        if (token === \"sBASH\") {\n            approveTx = await sBASHContract.approve(addresses.WSBASH_ADDRESS, ethers.constants.MaxUint256, { gasPrice });\n        }\n\n        const text = token === \"sBASH\" ? i18n.t(\"wrap:ApproveWrapping\") : \"\";\n        const pendingTxnType = token === \"sBASH\" ? \"approve_wrapping\" : \"\";\n\n        dispatch(fetchPendingTxns({ txnHash: approveTx.hash, text, type: pendingTxnType }));\n        await approveTx.wait();\n        dispatch(success({ text: messages.tx_successfully_send }));\n    } catch (err: any) {\n        return metamaskErrorWrap(err, dispatch);\n    } finally {\n        if (approveTx) {\n            dispatch(clearPendingTxn(approveTx.hash));\n        }\n    }\n\n    await sleep(2);\n\n    const wrapAllowance = await sBASHContract.allowance(address, addresses.WSBASH_ADDRESS);\n\n    return dispatch(\n        fetchAccountSuccess({\n            wrapping: {\n                sbWrap: Number(wrapAllowance),\n            },\n        }),\n    );\n});\n\ninterface IChangeWrap {\n    action: string;\n    value: string;\n    provider: StaticJsonRpcProvider | JsonRpcProvider;\n    address: string;\n    networkID: Networks;\n}\n\nexport const changeWrap = createAsyncThunk(\"stake/changeWrap\", async ({ action, value, provider, address, networkID }: IChangeWrap, { dispatch }) => {\n    if (!provider) {\n        dispatch(warning({ text: messages.please_connect_wallet }));\n        return;\n    }\n    const addresses = getAddresses(networkID);\n    const signer = provider.getSigner();\n    const wsBASH = new ethers.Contract(addresses.WSBASH_ADDRESS, WrappingContract, signer);\n\n    let wrapTx;\n\n    try {\n        const gasPrice = await getGasPrice(provider);\n\n        if (action === \"wrap\") {\n            console.log(value);\n            console.log(ethers.utils.parseEther(value));\n            wrapTx = await wsBASH.wrap(ethers.utils.parseUnits(value, \"gwei\"), { gasPrice });\n        } else {\n            wrapTx = await wsBASH.unwrap(ethers.utils.parseEther(value), { gasPrice });\n        }\n        const pendingTxnType = action === \"wrap\" ? i18n.t(\"wrap:Wrapping\") : i18n.t(\"wrap:Unwrapping\");\n        dispatch(fetchPendingTxns({ txnHash: wrapTx.hash, text: getStakingTypeText(action), type: pendingTxnType }));\n        await wrapTx.wait();\n        dispatch(success({ text: messages.tx_successfully_send }));\n    } catch (err: any) {\n        return metamaskErrorWrap(err, dispatch);\n    } finally {\n        if (wrapTx) {\n            dispatch(clearPendingTxn(wrapTx.hash));\n        }\n    }\n    dispatch(info({ text: messages.your_balance_update_soon }));\n    await sleep(10);\n    await dispatch(getBalances({ address, networkID, provider }));\n    dispatch(info({ text: messages.your_balance_updated }));\n    return;\n});\n"]},"metadata":{},"sourceType":"module"}