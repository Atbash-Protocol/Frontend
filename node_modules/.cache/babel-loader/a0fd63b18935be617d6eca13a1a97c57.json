{"ast":null,"code":"import { ethers } from \"ethers\";\nimport { getAddresses } from \"../../constants\";\nimport { StakingContract, MemoTokenContract, TimeTokenContract, RedeemContract } from \"../../abi\";\nimport { setAll, getMarketPrice, getTokenPrice } from \"../../helpers\";\nimport { createSlice, createSelector, createAsyncThunk } from \"@reduxjs/toolkit\";\nimport allBonds from \"../../helpers/bond\";\nexport const loadAppDetails = createAsyncThunk(\"app/loadAppDetails\", //@ts-ignore\nasync _ref => {\n  let {\n    networkID,\n    provider\n  } = _ref;\n  const mimPrice = getTokenPrice(\"MIM\");\n  const addresses = getAddresses(networkID);\n  const ohmPrice = getTokenPrice(\"OHM\");\n  const ohmAmount = 1512.12854088 * ohmPrice;\n  const stakingContract = new ethers.Contract(addresses.STAKING_ADDRESS, StakingContract, provider);\n  const redeemContract = new ethers.Contract(addresses.REDEEM_ADDRESS, RedeemContract, provider);\n  const currentBlock = await provider.getBlockNumber();\n  const currentBlockTime = (await provider.getBlock(currentBlock)).timestamp;\n  const sBASHContract = new ethers.Contract(addresses.SBASH_ADDRESS, MemoTokenContract, provider);\n  const sbContract = new ethers.Contract(addresses.BASH_ADDRESS, TimeTokenContract, provider);\n  const mimContract = new ethers.Contract(addresses.MIM_ADDRESS, TimeTokenContract, provider);\n  const marketPrice = (await getMarketPrice(networkID, provider)) / Math.pow(10, 9) * mimPrice;\n  const totalSupply = (await sbContract.totalSupply()) / Math.pow(10, 9);\n  const circSupply = (await sBASHContract.circulatingSupply()) / Math.pow(10, 9);\n  const stakingTVL = circSupply * marketPrice;\n  const marketCap = totalSupply * marketPrice;\n  const redeemRfv = (await redeemContract.RFV()) / Math.pow(10, 9);\n  const redeemSbSent = (await sbContract.balanceOf(addresses.REDEEM_ADDRESS)) / Math.pow(10, 9);\n  const redeemMimAvailable = (await mimContract.balanceOf(addresses.REDEEM_ADDRESS)) / Math.pow(10, 18);\n  const tokenBalPromises = allBonds.map(bond => bond.getTreasuryBalance(networkID, provider));\n  const tokenBalances = await Promise.all(tokenBalPromises);\n  const treasuryBalance = tokenBalances.reduce((tokenBalance0, tokenBalance1) => tokenBalance0 + tokenBalance1) + redeemMimAvailable + 16176498;\n  const tokenAmountsPromises = allBonds.map(bond => bond.getTokenAmount(networkID, provider));\n  const tokenAmounts = await Promise.all(tokenAmountsPromises);\n  const rfvTreasury = tokenBalances[0] + tokenBalances[1] + redeemMimAvailable + tokenBalances[2] / 2 + tokenBalances[3] / 2 + 16176498;\n  const daoSb = await sbContract.balanceOf(addresses.DAO_ADDRESS);\n  const daoSbAmount = Number(ethers.utils.formatUnits(daoSb, \"gwei\"));\n  const sbBondsAmountsPromises = allBonds.filter(bond => bond.name !== \"bash_dai_minting\").map(bond => bond.getSbAmount(networkID, provider));\n  const sbBondsAmounts = await Promise.all(sbBondsAmountsPromises);\n  const LpSbAmount = sbBondsAmounts.reduce((sbAmount0, sbAmount1) => sbAmount0 + sbAmount1, 0);\n  const sbSupply = totalSupply - LpSbAmount - daoSbAmount;\n  const rfv = rfvTreasury / (sbSupply - redeemSbSent);\n  const deltaMarketPriceRfv = (rfv - marketPrice) / rfv * 100;\n  const epoch = await stakingContract.epoch();\n  const stakingReward = epoch.distribute;\n  const circ = await sBASHContract.circulatingSupply();\n  const stakingRebase = stakingReward / circ;\n  const fiveDayRate = Math.pow(1 + stakingRebase, 5 * 3) - 1;\n  const stakingAPY = Math.pow(1 + stakingRebase, 365 * 3) - 1;\n  const currentIndex = await stakingContract.index();\n  const nextRebase = epoch.endTime;\n  const treasuryRunway = rfvTreasury / circSupply;\n  const runway = Math.log(treasuryRunway) / Math.log(1 + stakingRebase) / 3;\n  return {\n    currentIndex: Number(ethers.utils.formatUnits(currentIndex, \"gwei\")),\n    totalSupply,\n    marketCap,\n    currentBlock,\n    circSupply,\n    fiveDayRate,\n    treasuryBalance,\n    stakingAPY,\n    stakingTVL,\n    stakingRebase,\n    marketPrice,\n    deltaMarketPriceRfv,\n    currentBlockTime,\n    nextRebase,\n    rfv,\n    runway,\n    redeemRfv,\n    redeemSbSent,\n    redeemMimAvailable\n  };\n});\nconst initialState = {\n  loading: true\n};\nconst appSlice = createSlice({\n  name: \"app\",\n  initialState,\n  reducers: {\n    fetchAppSuccess(state, action) {\n      setAll(state, action.payload);\n    }\n\n  },\n  extraReducers: builder => {\n    builder.addCase(loadAppDetails.pending, (state, action) => {\n      state.loading = true;\n    }).addCase(loadAppDetails.fulfilled, (state, action) => {\n      setAll(state, action.payload);\n      state.loading = false;\n    }).addCase(loadAppDetails.rejected, (state, _ref2) => {\n      let {\n        error\n      } = _ref2;\n      state.loading = false;\n      console.log(error);\n    });\n  }\n});\n\nconst baseInfo = state => state.app;\n\nexport default appSlice.reducer;\nexport const {\n  fetchAppSuccess\n} = appSlice.actions;\nexport const getAppState = createSelector(baseInfo, app => app);","map":{"version":3,"sources":["/home/beard/Documents/V1Frontend/v1-frontend/src/store/slices/app-slice.ts"],"names":["ethers","getAddresses","StakingContract","MemoTokenContract","TimeTokenContract","RedeemContract","setAll","getMarketPrice","getTokenPrice","createSlice","createSelector","createAsyncThunk","allBonds","loadAppDetails","networkID","provider","mimPrice","addresses","ohmPrice","ohmAmount","stakingContract","Contract","STAKING_ADDRESS","redeemContract","REDEEM_ADDRESS","currentBlock","getBlockNumber","currentBlockTime","getBlock","timestamp","sBASHContract","SBASH_ADDRESS","sbContract","BASH_ADDRESS","mimContract","MIM_ADDRESS","marketPrice","Math","pow","totalSupply","circSupply","circulatingSupply","stakingTVL","marketCap","redeemRfv","RFV","redeemSbSent","balanceOf","redeemMimAvailable","tokenBalPromises","map","bond","getTreasuryBalance","tokenBalances","Promise","all","treasuryBalance","reduce","tokenBalance0","tokenBalance1","tokenAmountsPromises","getTokenAmount","tokenAmounts","rfvTreasury","daoSb","DAO_ADDRESS","daoSbAmount","Number","utils","formatUnits","sbBondsAmountsPromises","filter","name","getSbAmount","sbBondsAmounts","LpSbAmount","sbAmount0","sbAmount1","sbSupply","rfv","deltaMarketPriceRfv","epoch","stakingReward","distribute","circ","stakingRebase","fiveDayRate","stakingAPY","currentIndex","index","nextRebase","endTime","treasuryRunway","runway","log","initialState","loading","appSlice","reducers","fetchAppSuccess","state","action","payload","extraReducers","builder","addCase","pending","fulfilled","rejected","error","console","baseInfo","app","reducer","actions","getAppState"],"mappings":"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","sourcesContent":["import { ethers } from \"ethers\";\nimport { getAddresses } from \"../../constants\";\nimport { StakingContract, MemoTokenContract, TimeTokenContract, RedeemContract } from \"../../abi\";\nimport { setAll, getMarketPrice, getTokenPrice } from \"../../helpers\";\nimport { createSlice, createSelector, createAsyncThunk } from \"@reduxjs/toolkit\";\nimport { JsonRpcProvider } from \"@ethersproject/providers\";\nimport { RootState } from \"../store\";\nimport allBonds from \"../../helpers/bond\";\n\ninterface ILoadAppDetails {\n    networkID: number;\n    provider: JsonRpcProvider;\n}\n\nexport const loadAppDetails = createAsyncThunk(\n    \"app/loadAppDetails\",\n    //@ts-ignore\n    async ({ networkID, provider }: ILoadAppDetails) => {\n        const mimPrice = getTokenPrice(\"MIM\");\n        const addresses = getAddresses(networkID);\n\n        const ohmPrice = getTokenPrice(\"OHM\");\n        const ohmAmount = 1512.12854088 * ohmPrice;\n\n        const stakingContract = new ethers.Contract(addresses.STAKING_ADDRESS, StakingContract, provider);\n        const redeemContract = new ethers.Contract(addresses.REDEEM_ADDRESS, RedeemContract, provider);\n        const currentBlock = await provider.getBlockNumber();\n        const currentBlockTime = (await provider.getBlock(currentBlock)).timestamp;\n        const sBASHContract = new ethers.Contract(addresses.SBASH_ADDRESS, MemoTokenContract, provider);\n        const sbContract = new ethers.Contract(addresses.BASH_ADDRESS, TimeTokenContract, provider);\n        const mimContract = new ethers.Contract(addresses.MIM_ADDRESS, TimeTokenContract, provider);\n\n        const marketPrice = ((await getMarketPrice(networkID, provider)) / Math.pow(10, 9)) * mimPrice;\n\n        const totalSupply = (await sbContract.totalSupply()) / Math.pow(10, 9);\n        const circSupply = (await sBASHContract.circulatingSupply()) / Math.pow(10, 9);\n\n        const stakingTVL = circSupply * marketPrice;\n        const marketCap = totalSupply * marketPrice;\n\n        const redeemRfv = (await redeemContract.RFV()) / Math.pow(10, 9);\n        const redeemSbSent = (await sbContract.balanceOf(addresses.REDEEM_ADDRESS)) / Math.pow(10, 9);\n        const redeemMimAvailable = (await mimContract.balanceOf(addresses.REDEEM_ADDRESS)) / Math.pow(10, 18);\n\n        const tokenBalPromises = allBonds.map(bond => bond.getTreasuryBalance(networkID, provider));\n        const tokenBalances = await Promise.all(tokenBalPromises);\n        const treasuryBalance = tokenBalances.reduce((tokenBalance0, tokenBalance1) => tokenBalance0 + tokenBalance1) + redeemMimAvailable + 16176498;\n\n        const tokenAmountsPromises = allBonds.map(bond => bond.getTokenAmount(networkID, provider));\n        const tokenAmounts = await Promise.all(tokenAmountsPromises);\n\n        const rfvTreasury = tokenBalances[0] + tokenBalances[1] + redeemMimAvailable + tokenBalances[2] / 2 + tokenBalances[3] / 2 + 16176498;\n\n        const daoSb = await sbContract.balanceOf(addresses.DAO_ADDRESS);\n        const daoSbAmount = Number(ethers.utils.formatUnits(daoSb, \"gwei\"));\n\n        const sbBondsAmountsPromises = allBonds.filter(bond => bond.name !== \"bash_dai_minting\").map(bond => bond.getSbAmount(networkID, provider));\n        const sbBondsAmounts = await Promise.all(sbBondsAmountsPromises);\n\n        const LpSbAmount = sbBondsAmounts.reduce((sbAmount0, sbAmount1) => sbAmount0 + sbAmount1, 0);\n        const sbSupply = totalSupply - LpSbAmount - daoSbAmount;\n\n        const rfv = rfvTreasury / (sbSupply - redeemSbSent);\n        const deltaMarketPriceRfv = ((rfv - marketPrice) / rfv) * 100;\n\n        const epoch = await stakingContract.epoch();\n        const stakingReward = epoch.distribute;\n        const circ = await sBASHContract.circulatingSupply();\n        const stakingRebase = stakingReward / circ;\n        const fiveDayRate = Math.pow(1 + stakingRebase, 5 * 3) - 1;\n        const stakingAPY = Math.pow(1 + stakingRebase, 365 * 3) - 1;\n\n        const currentIndex = await stakingContract.index();\n        const nextRebase = epoch.endTime;\n\n        const treasuryRunway = rfvTreasury / circSupply;\n        const runway = Math.log(treasuryRunway) / Math.log(1 + stakingRebase) / 3;\n\n        return {\n            currentIndex: Number(ethers.utils.formatUnits(currentIndex, \"gwei\")),\n            totalSupply,\n            marketCap,\n            currentBlock,\n            circSupply,\n            fiveDayRate,\n            treasuryBalance,\n            stakingAPY,\n            stakingTVL,\n            stakingRebase,\n            marketPrice,\n            deltaMarketPriceRfv,\n            currentBlockTime,\n            nextRebase,\n            rfv,\n            runway,\n            redeemRfv,\n            redeemSbSent,\n            redeemMimAvailable,\n        };\n    },\n);\n\nconst initialState = {\n    loading: true,\n};\n\nexport interface IAppSlice {\n    loading: boolean;\n    stakingTVL: number;\n    marketPrice: number;\n    deltaMarketPriceRfv: number;\n    marketCap: number;\n    circSupply: number;\n    currentIndex: string;\n    currentBlock: number;\n    currentBlockTime: number;\n    fiveDayRate: number;\n    treasuryBalance: number;\n    stakingAPY: number;\n    stakingRebase: number;\n    networkID: number;\n    nextRebase: number;\n    totalSupply: number;\n    rfv: number;\n    runway: number;\n    redeemRfv: number;\n    redeemSbSent: number;\n    redeemMimAvailable: number;\n}\n\nconst appSlice = createSlice({\n    name: \"app\",\n    initialState,\n    reducers: {\n        fetchAppSuccess(state, action) {\n            setAll(state, action.payload);\n        },\n    },\n    extraReducers: builder => {\n        builder\n            .addCase(loadAppDetails.pending, (state, action) => {\n                state.loading = true;\n            })\n            .addCase(loadAppDetails.fulfilled, (state, action) => {\n                setAll(state, action.payload);\n                state.loading = false;\n            })\n            .addCase(loadAppDetails.rejected, (state, { error }) => {\n                state.loading = false;\n                console.log(error);\n            });\n    },\n});\n\nconst baseInfo = (state: RootState) => state.app;\n\nexport default appSlice.reducer;\n\nexport const { fetchAppSuccess } = appSlice.actions;\n\nexport const getAppState = createSelector(baseInfo, app => app);\n"]},"metadata":{},"sourceType":"module"}